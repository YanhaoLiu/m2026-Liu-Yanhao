#include <avr/io.h>

long freqclk = 1000000;   // 1 MHz default clock

// PORTC values for LEDs (ACTIVE-LOW, and we set the WHOLE PORT)
 //  If LEDs are on PC0 and PC1:
 //   OFF means output HIGH on those pins: PORTC bit = 1
 //   ON  means output LOW  on those pins: PORTC bit = 0

unsigned char LEDS_OFF = 0b11111111;  // all HIGH -> both LEDs OFF (active-low)
unsigned char LEDS_ON  = 0b11111100;  // PC1=0, PC0=0 -> both LEDs ON, others HIGH

void delay_1_msec_timer0()
{
    TCCR0B = 0b00000000;
    TCCR0A = 0b00000000;
    TCNT0 = 131;   // default clock =1MHz and prescalar=8,1ms=125ticks
					/* we wish overflow after 125tick,so counter TCNT0=256 - 125 = 131*/

    TIFR0 = 0b00000001;   // clear the overflow flag,If we don't clear it, a previous overflow could make us exit immediately.
							//bit0 = TOV0 = 1
  
     
    TCCR0B = 0b00000010; //start timer0, prescaler=8
						// CS02 CS01 CS00 = 0 1 0 means clock/8.*/

  
   
     
    while ( (TIFR0 & 0b00000001) == 0 )//wait until overflow
										// When overflow happens, hardware sets TOV0 = 1
										//(which is the bit0 of the TIFR0)
    {
        /* Do nothing ;) timer is counting*/
    }

    TCCR0B = 0b00000000; // Stop to avoid unintended continuous counting.
}

void wait(volatile int N) //N=ms
{
    while (N > 1)
    {
        N--;
        delay_1_msec_timer0();   // 1 ms delay using timer/counter register
									// as long as N>1, continue 1ms delay
    }
}



void pause_if_pressed()
{
	// PD2 is bit2 -> mask 0b00000100; pressed means that bit reads 0 */
	//  If PD2 is LOW (pressed), pause in a loop until it becomes HIGH again.
	//  DO NOT change PORTC inside this function so LED state is held.
	if ( (PIND & 0b00000100) == 0 )//check PD2 (bit2) 0 means pressed
	{
		while ( (PIND & 0b00000100) == 0 )// as long as the button stays pressed
		{
			// Hold current LED state; do not change PORTC 
		}
	}
}

int main(void)
{
    DDRC  = 0b11111111;    // all PORTC pins output
    PORTC = LEDS_OFF;      // start with LEDs OFF (required while waiting)
    DDRD  = DDRD & 0b11111011;   // clear bit2 and set PD2 input
    PORTD = PORTD | 0b00000100;  // set bit2 and pull up ON
    char pattern[] = {
        'A','C','B','C','A','C','A','D','A','D','B','C','B','C','A','D','B','C','B','C','B'
    };
    int pattern_len = sizeof(pattern) / sizeof(pattern[0]);
	 while ( (PIND & 0b00000100) != 0 )//no press: pd2=1, press, pd2=0,out of while loop
        {
            // Keep waiting 
        }
        while ( (PIND & 0b00000100) == 0 )
        {
            /* Wait until switch released */
        }
    while (1)
    {
        PORTC = LEDS_OFF; //make sure LED is off

       

        for (int i = 0; i < pattern_len; i++)
        {
            // Only check pause at transitions (before applying next state)
            pause_if_pressed();

            
            char step = pattern[i];// Read current step letter 
            if (step == 'A' || step == 'B')// Set LED state (A/B = ON, C/D = OFF),A and B means both on
            {
                PORTC = LEDS_ON;
            }
            else //not AandB so it is C and D
            {
                PORTC = LEDS_OFF;    // both LEDs OFF
            }
			
            if (step == 'A' || step == 'C')//AandC, wait 200ms
            {
                wait(200);
            }
            else//not A and C then it is B and D, wait 600ms
            {
                wait(600);
            }
        }

        PORTC = LEDS_OFF; //when finish, let LED off
        wait(2000);

 
    }

    return 0;  
}
